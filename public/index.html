<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <title>ðŸ•µ Investigating Reactivity</title>
</head>
<body>

<div id="root"></div>

<script type="text/jsx">

  const api = {
    get(url) {
      switch (url) {
        case '/lots': {
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve([
                {
                  id: 1,
                  name: 'Apple',
                  description: 'Apple description',
                  price: 16
                },
                {
                  id: 2,
                  name: 'Orange',
                  description: 'Orange description',
                  price: 41
                }
              ]);
            }, 1000)
          });
        }
        default: {
          throw new Error('Unknown address');
        }
      }
    }
  }

  const stream = {
    subscribe(channel, listener) {
      const match = /price-(\d+)/.exec(channel);

      if (match) {
        setInterval(() => {
          listener({
            id: parseInt(match[1]),
            price: Math.round((Math.random() * 10 + 30))
          });
        }, 400);
      }
    }
  }

  let state = {
    time: new Date(),
    lots: null
  }

  function App({ state }) {
    return (
      <div className="app">
        <Header />
        <Clock time={state.time} />
        <Lots lots={state.lots} />
      </div>
    );
  }

  function Loading() {
    return (
      <div className="loading">
        Loading...
      </div>
    );
  }

  function Header() {
    return (
      <header className="header">
        <Logo />
      </header>
    );
  }

  function Logo() {
    return (
      <img
        className="logo"
        src="logo.png"
        alt="logo"
      />
    );
  }

  function Clock({ time }) {
    const isDay = time.getHours() >= 7 && time.getHours() <= 21;

    return (
      <div className="clock">
        <span className="value">
          {time.toLocaleTimeString()}
        </span>
        <span className={isDay ? 'icon day' : 'icon night'} />
      </div>
    );
  }

  function Lots({ lots }) {
    if (lots === null) {
      return <Loading />;
    }

    return (
      <div className="lots">
        {
          lots.map(
            (lot) => <Lot lot={lot} key={lot.id} />
          )}
      </div>
    );
  }

  function Lot({ lot }) {
    return (
      <article className="lot">
        <div className="price">
          {lot.price}
        </div>
        <h1>{lot.name}</h1>
        <div>{lot.description}</div>
      </article>
    );
  }

  function renderView(state) {
    ReactDOM.render(
      <App state={state} />,
      document.getElementById('root')
    );
  }

  renderView(state);

  setInterval(() => {
    state = {
      ...state,
      time: new Date()
    };

    renderView(state);
  }, 1000);

  api.get('/lots').then((lots) => {
    state = {
      ...state,
      lots
    };

    renderView(state);

    const onPrice = (data) => {
      state = {
        ...state,
        lots: state.lots.map((lot) => {
          if (lot.id === data.id) {
            return {
              ...lot,
              price: data.price
            }
          }
          return lot;
        })
      }

      renderView(state);
    }

    lots.forEach((lot) => {
      stream.subscribe(`price-${lot.id}`, onPrice);
    });
  });

  function render(virtualDom, realDomRoot) {
    const evaluatedVirtualDom = evaluate(virtualDom);

    const virtualDomRoot = {
      type: realDomRoot.tagName.toLowerCase(),
      props: {
        id: realDomRoot.id,
        ...realDomRoot.attributes,
        children: [
          evaluatedVirtualDom
        ]
      }
    }

    sync(virtualDomRoot, realDomRoot);
  }

  function evaluate(virtualNode) {
    if (typeof virtualNode !== 'object') {
      return virtualNode;
    }

    if (typeof virtualNode.type === 'function') {
      return evaluate(
        (virtualNode.type)(virtualNode.props)
      );
    }

    const props = virtualNode.props || {};

    return {
      ...virtualNode,
      props: {
        ...props,
        children: Array.isArray(props.children)
          ? props.children.map(evaluate)
          : [evaluate(props.children)]
      }
    }
  }

  function sync(virtualNode, realNode) {
    // sync element
    if (virtualNode.props) {
      Object.entries(virtualNode.props).forEach(([name, value]) => {
        if (name === 'children' || name === 'key') {
          return;
        }

        if (realNode[name] !== value) {
          realNode[name] = value;
        }
      });
    }

    if (virtualNode.key) {
      realNode.dataset.key = virtualNode.key;
    }

    if (typeof virtualNode !== 'object' && virtualNode !== realNode.nodeValue) {
      realNode.nodeValue = virtualNode;
    }

    // sync child nodes

    const virtualChildren = virtualNode.props
      ? virtualNode.props.children || []
      : [];
    const readChildren = realNode.childNodes;

    for (let i = 0; i < virtualChildren.length || i < readChildren.length; i++) {
      const virtualChild = virtualChildren[i];
      const realChild = readChildren[i];

      // Remove
      if (virtualChild === undefined && realChild !== undefined) {
        realNode.remove(realChild);
      }

      // Update
      if (virtualChild !== undefined && realChild !== undefined && (virtualChild.type || '') === (realChild.tagName || '').toLowerCase()) {
        sync(virtualChild, realChild);
      }

      // Replace
      if (virtualChild !== undefined && realChild !== undefined && (virtualChild.type || '') !== (realChild.tagName || '').toLowerCase()) {
        const newRealChild = createRealModeByVirtual(virtualChild);
        sync(virtualChild, newRealChild);

        realNode.replaceChild(newRealChild, realChild);
      }

      // Add
      if (virtualChild !== undefined && realChild === undefined) {
        const newRealChild = createRealModeByVirtual(virtualChild);
        sync(virtualChild, newRealChild);

        realNode.appendChild(newRealChild);
      }
    }
  }

  function createRealModeByVirtual(virtual) {
    if (typeof virtual !== 'object') {
      return document.createTextNode('');
    }

    return document.createElement(virtual.type);
  }

</script>

</body>
</html>

<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://unpkg.com/mocha@10/mocha.css">
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>
    <script src="https://unpkg.com/redux@4/dist/redux.js" crossorigin></script>
    <script src="https://unpkg.com/react-redux@8/dist/react-redux.js" crossorigin></script>
    <script src="https://unpkg.com/redux-thunk@2/dist/redux-thunk.js" crossorigin></script>
    <script src="https://unpkg.com/ionicons@7/dist/ionicons.js" crossorigin></script>
    <script src="https://unpkg.com/mocha@10/mocha.js" crossorigin></script>
    <script src="https://unpkg.com/chai@4/chai.js" crossorigin></script>
    <title>ðŸ•µ Investigating Reactivity</title>
</head>
<body>

<div id="mocha"></div>

<div id="root"></div>

<script type="text/jsx">

  const api = {
    get(url) {
      switch (url) {
        case '/lots': {
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve([
                {
                  id: 1,
                  name: 'Apple',
                  description: 'Apple description',
                  price: 16,
                  is_favorite: true
                },
                {
                  id: 2,
                  name: 'Orange',
                  description: 'Orange description',
                  price: 41,
                  is_favorite: false
                }
              ]);
            }, 1500)
          });
        }
        default: {
          throw new Error('Unknown address');
        }
      }
    },
    post(url) {
      if (/^\/lots\/(\d+)\/toggle-favorite$/.exec(url)) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve();
          }, 500);
        })
      }
      throw new Error('Unknown address');
    }
  }

  const stream = {
    subscribe(channel, listener) {
      const match = /price-(\d+)/.exec(channel);

      if (match) {
        setInterval(() => {
          listener({
            id: parseInt(match[1]),
            price: Math.round((Math.random() * 10 + 30))
          });
        }, 400);
      }
    }
  }

  const clockInitialState = {
    time: new Date(),
  }

  const SET_TIME = 'SET_TIME';

  function clockReducer(state = clockInitialState, action) {
    switch (action.type) {
      case SET_TIME:
        return {
          ...state,
          time: action.time
        };
      default:
        return state;
    }
  }

  function setTime(time) {
    return {
      type: SET_TIME,
      time
    }
  }

  const auctionInitialState = {
    lots: null
  }

  const SET_LOTS = 'SET_LOTS';
  const CHANGE_LOT_PRICE = 'UPDATE_LOT_PRICE';
  const TOGGLE_FAVORITE_LOT = 'TOGGLE_FAVORITE';

  function auctionReducer(state = auctionInitialState, action) {
    switch (action.type) {
      case SET_LOTS:
        return {
          ...state,
          lots: action.lots
        };
      case CHANGE_LOT_PRICE:
        return {
          ...state,
          lots: state.lots.map((lot) => {
            if (lot.id === action.id) {
              return {
                ...lot,
                price: action.price
              }
            }
            return lot;
          })
        };
      case TOGGLE_FAVORITE_LOT:
        return {
          ...state,
          lots: state.lots.map((lot) => {
            if (lot.id === action.id) {
              return {
                ...lot,
                is_favorite: !lot.is_favorite
              };
            }
            return lot;
          })
        }
      default:
        return state;
    }
  }

  function setLots(lots) {
    return {
      type: SET_LOTS,
      lots
    }
  }

  function changeLotPrice(id, price) {
    return {
      type: CHANGE_LOT_PRICE,
      id,
      price
    }
  }

  function toggleFavoriteLot(id) {
    return {
      type: TOGGLE_FAVORITE_LOT,
      id
    }
  }

  function toggleFavoriteAsync(id) {
    return (dispatch, getState, { api }) => {
      api.post(`/lots/${id}/toggle-favorite`).then(() => {
        dispatch(toggleFavoriteLot(id));
      })
    };
  }

  const thunk = ReduxThunk;

  const store = Redux.createStore(
    Redux.combineReducers({
      clock: clockReducer,
      auction: auctionReducer
    }),
    Redux.applyMiddleware(thunk.withExtraArgument({ api }))
  );

  const StoreContext = React.createContext();

  function connect(mapStateToProps, mapDispatchToProps) {
    return (WrappedComponent) => {
      return (props) => {
        return (
          <StoreContext.Consumer>
            {(store) => {
              return React.createElement(
                class extends React.Component {
                  render() {
                    const state = store.getState();
                    const { dispatch } = store;

                    const stateToProps = mapStateToProps ? mapStateToProps(state) : {};
                    const dispatchToProps = mapDispatchToProps ? mapDispatchToProps(dispatch) : {};

                    return (
                      <WrappedComponent
                        {...this.props}
                        {...stateToProps}
                        {...dispatchToProps}
                      />
                    );
                  }
                  componentDidMount() {
                    this.unsubscribe = store.subscribe(
                      this.handleChange.bind(this)
                    );
                  }
                  componentWillUnmount() {
                    this.unsubscribe();
                  }
                  handleChange() {
                    this.forceUpdate()
                  }
                },
                props
              );
            }}
          </StoreContext.Consumer>
        );
      }
    }
  }

  function App() {
    return (
      <div className="app">
        <Header />
        <ClockConnected />
        <LotsConnected />
      </div>
    );
  }

  function Loading() {
    return (
      <div className="loading">
        Loading...
      </div>
    );
  }

  function Header() {
    return (
      <header className="header">
        <Logo />
      </header>
    );
  }

  function Logo() {
    return (
      <img
        className="logo"
        src="logo.png"
        alt="Logotype"
      />
    );
  }

  const clockMapStateToProps = (state) => ({
    time: state.clock.time
  });

  const ClockConnected = ReactRedux.connect(clockMapStateToProps, null)(Clock);

  function Clock({ time }) {
    const isDay = time.getHours() >= 7 && time.getHours() <= 21;

    return (
      <div className="clock">
        <span className="value">
          {time.toLocaleTimeString()}
        </span>
        <span className={isDay ? 'icon day' : 'icon night'} />
      </div>
    );
  }

  //  tests

  // mocha.setup('bdd');
  // const assert = chai.assert;
  //
  // describe('Clock', () => {
  //
  //   it('Render time of day', () => {
  //     const container = document.createElement('div');
  //
  //     ReactDOM.render(
  //       <Clock time={new Date('2023-06-11T13:51:20')} />,
  //       container
  //     );
  //
  //     const clock = container.querySelector('.clock');
  //
  //     assert.equal(clock.querySelector('.value').innerText, '1:51:20 PM');
  //     assert.equal(clock.querySelector('.icon').className, 'icon day');
  //   });
  //
  //   it('Render time of night', () => {
  //     const container = document.createElement('div');
  //
  //     ReactDOM.render(
  //     <Clock time={new Date('2023-06-12T04:20:00')} />,
  //     container
  //     );
  //
  //     const clock = container.querySelector('.clock');
  //
  //     assert.equal(clock.querySelector('.value').innerText, '4:20:00 AM');
  //     assert.equal(clock.querySelector('.icon').className, 'icon night');
  //   });
  // });
  //
  // mocha.run();

  const lotsMapStateToProps = (state) => ({
    lots: state.auction.lots
  });

  const LotsConnected = ReactRedux.connect(lotsMapStateToProps, null)(Lots);

  function Lots({ lots }) {
    if (lots === null) {
      return <Loading />;
    }

    return (
      <div className="lots">
        {
          lots.map(
            (lot) => <LotConnected key={lot.id} lot={lot} />
          )
        }
      </div>
    );
  }

  const lotMapDispatchToProps = {
    toggleFavorite: toggleFavoriteAsync
  };

  const LotConnected = ReactRedux.connect(null, lotMapDispatchToProps)(Lot);

  function Lot({ lot, toggleFavorite }) {
    return (
      <article className={`lot` + (lot.is_favorite ? ' favorite' : '')}>
        <div className="price">
          {lot.price}
        </div>
        <h1>{lot.name}</h1>
        <div>{lot.description}</div>
        <Favorite
          isFavorite={lot.is_favorite}
          toggleFavorite={() => toggleFavorite(lot.id)}
        />
      </article>
    );
  }

  function Favorite({ isFavorite, toggleFavorite }) {
    return (
      <button
        type="button"
        onClick={toggleFavorite}
        className={isFavorite ? 'unfavorite' : 'favorite' }
      >
        <ion-icon name={isFavorite ? 'heart-sharp' : 'heart-outline'} />
        {
          isFavorite
            ? 'Unfavorite'
            : 'Favorite'
        }
      </button>
    );
  }

  function renderView(store) {
    ReactDOM.render(
      <ReactRedux.Provider store={store}>
        <App />
      </ReactRedux.Provider>,
      document.getElementById('root')
    );
  }

  store.subscribe(() => {
    renderView(store);
  });

  renderView(store);

  setInterval(() => {
    store.dispatch(setTime(new Date()));
  }, 1000);

  api.get('/lots').then((lots) => {
    store.dispatch(setLots(lots));

    lots.forEach((lot) => {
      stream.subscribe(`price-${lot.id}`, (data) => {
        store.dispatch(changeLotPrice(data.id, data.price));
      });
    });
  });

  function render(virtualDom, realDomRoot) {
    const evaluatedVirtualDom = evaluate(virtualDom);

    const virtualDomRoot = {
      type: realDomRoot.tagName.toLowerCase(),
      props: {
        id: realDomRoot.id,
        ...realDomRoot.attributes,
        children: [
          evaluatedVirtualDom
        ]
      }
    }

    sync(virtualDomRoot, realDomRoot);
  }

  function evaluate(virtualNode) {
    if (typeof virtualNode !== 'object') {
      return virtualNode;
    }

    if (typeof virtualNode.type === 'function') {
      return evaluate(
        (virtualNode.type)(virtualNode.props)
      );
    }

    const props = virtualNode.props || {};

    return {
      ...virtualNode,
      props: {
        ...props,
        children: Array.isArray(props.children)
          ? props.children.map(evaluate)
          : [evaluate(props.children)]
      }
    }
  }

  function sync(virtualNode, realNode) {
    // sync element
    if (virtualNode.props) {
      Object.entries(virtualNode.props).forEach(([name, value]) => {
        if (name === 'children' || name === 'key') {
          return;
        }

        if (realNode[name] !== value) {
          realNode[name] = value;
        }
      });
    }

    if (virtualNode.key) {
      realNode.dataset.key = virtualNode.key;
    }

    if (typeof virtualNode !== 'object' && virtualNode !== realNode.nodeValue) {
      realNode.nodeValue = virtualNode;
    }

    // sync child nodes

    const virtualChildren = virtualNode.props
      ? virtualNode.props.children || []
      : [];
    const readChildren = realNode.childNodes;

    for (let i = 0; i < virtualChildren.length || i < readChildren.length; i++) {
      const virtualChild = virtualChildren[i];
      const realChild = readChildren[i];

      // Remove
      if (virtualChild === undefined && realChild !== undefined) {
        realNode.remove(realChild);
      }

      // Update
      if (virtualChild !== undefined && realChild !== undefined && (virtualChild.type || '') === (realChild.tagName || '').toLowerCase()) {
        sync(virtualChild, realChild);
      }

      // Replace
      if (virtualChild !== undefined && realChild !== undefined && (virtualChild.type || '') !== (realChild.tagName || '').toLowerCase()) {
        const newRealChild = createRealModeByVirtual(virtualChild);
        sync(virtualChild, newRealChild);

        realNode.replaceChild(newRealChild, realChild);
      }

      // Add
      if (virtualChild !== undefined && realChild === undefined) {
        const newRealChild = createRealModeByVirtual(virtualChild);
        sync(virtualChild, newRealChild);

        realNode.appendChild(newRealChild);
      }
    }
  }

  function createRealModeByVirtual(virtual) {
    if (typeof virtual !== 'object') {
      return document.createTextNode('');
    }

    return document.createElement(virtual.type);
  }

</script>

</body>
</html>

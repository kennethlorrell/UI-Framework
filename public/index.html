<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>
    <script src="https://unpkg.com/redux@4.2.1/dist/redux.js" crossorigin></script>
    <script src="https://unpkg.com/ionicons@7.1.0/dist/ionicons.js" crossorigin></script>
    <title>ðŸ•µ Investigating Reactivity</title>
</head>
<body>

<div id="root"></div>

<script type="text/jsx">

  const api = {
    get(url) {
      switch (url) {
        case '/lots': {
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve([
                {
                  id: 1,
                  name: 'Apple',
                  description: 'Apple description',
                  price: 16,
                  is_favorite: true
                },
                {
                  id: 2,
                  name: 'Orange',
                  description: 'Orange description',
                  price: 41,
                  is_favorite: false
                }
              ]);
            }, 1500)
          });
        }
        default: {
          throw new Error('Unknown address');
        }
      }
    },
    post(url) {
      if (/^\/lots\/(\d+)\/toggle-favorite$/.exec(url)) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve();
          }, 500);
        })
      }
      throw new Error('Unknown address');
    }
  }

  const stream = {
    subscribe(channel, listener) {
      const match = /price-(\d+)/.exec(channel);

      if (match) {
        setInterval(() => {
          listener({
            id: parseInt(match[1]),
            price: Math.round((Math.random() * 10 + 30))
          });
        }, 400);
      }
    }
  }

  const clockInitialState = {
    time: new Date(),
  }

  const SET_TIME = 'SET_TIME';

  function clockReducer(state = clockInitialState, action) {
    switch (action.type) {
      case SET_TIME:
        return {
          ...state,
          time: action.time
        };
      default:
        return state;
    }
  }

  function setTime(time) {
    return {
      type: SET_TIME,
      time
    }
  }

  const auctionInitialState = {
    lots: null
  }

  const SET_LOTS = 'SET_LOTS';
  const CHANGE_LOT_PRICE = 'UPDATE_LOT_PRICE';
  const TOGGLE_FAVORITE_LOT = 'TOGGLE_FAVORITE';

  function auctionReducer(state = auctionInitialState, action) {
    switch (action.type) {
      case SET_LOTS:
        return {
          ...state,
          lots: action.lots
        };
      case CHANGE_LOT_PRICE:
        return {
          ...state,
          lots: state.lots.map((lot) => {
            if (lot.id === action.id) {
              return {
                ...lot,
                price: action.price
              }
            }
            return lot;
          })
        };
      case TOGGLE_FAVORITE_LOT:
        return {
          ...state,
          lots: state.lots.map((lot) => {
            if (lot.id === action.id) {
              return {
                ...lot,
                is_favorite: !lot.is_favorite
              };
            }
            return lot;
          })
        }
      default:
        return state;
    }
  }

  function setLots(lots) {
    return {
      type: SET_LOTS,
      lots
    }
  }

  function changeLotPrice(id, price) {
    return {
      type: CHANGE_LOT_PRICE,
      id,
      price
    }
  }

  function toggleFavoriteLot(id) {
    return {
      type: TOGGLE_FAVORITE_LOT,
      id
    }
  }

  const store = Redux.createStore(Redux.combineReducers({
    clock: clockReducer,
    auction: auctionReducer
  }));

  function App({ state, toggleFavorite }) {
    return (
      <div className="app">
        <Header />
        <Clock time={state.clock.time} />
        <Lots lots={state.auction.lots} toggleFavorite={toggleFavorite} />
      </div>
    );
  }

  function Loading() {
    return (
      <div className="loading">
        Loading...
      </div>
    );
  }

  function Header() {
    return (
      <header className="header">
        <Logo />
      </header>
    );
  }

  function Logo() {
    return (
      <img
        className="logo"
        src="logo.png"
        alt="logo"
      />
    );
  }

  function Clock({ time }) {
    const isDay = time.getHours() >= 7 && time.getHours() <= 21;

    return (
      <div className="clock">
        <span className="value">
          {time.toLocaleTimeString()}
        </span>
        <span className={isDay ? 'icon day' : 'icon night'} />
      </div>
    );
  }

  function Lots({ lots, toggleFavorite }) {
    if (lots === null) {
      return <Loading />;
    }

    return (
      <div className="lots">
        {
          lots.map(
            (lot) => (
              <Lot
                lot={lot}
                key={lot.id}
                toggleFavorite={toggleFavorite}
              />
            )
          )}
      </div>
    );
  }

  function Lot({ lot, toggleFavorite }) {
    return (
      <article className={`lot` + (lot.is_favorite ? ' favorite' : '')}>
        <div className="price">
          {lot.price}
        </div>
        <h1>{lot.name}</h1>
        <div>{lot.description}</div>
        <Favorite
          isFavorite={lot.is_favorite}
          toggleFavorite={() => toggleFavorite(lot.id)}
        />
      </article>
    );
  }

  function Favorite({ isFavorite, toggleFavorite }) {
    return (
      <button
        type="button"
        onClick={toggleFavorite}
        className={isFavorite ? 'unfavorite' : 'favorite' }
      >
        <ion-icon name={isFavorite ? 'heart-sharp' : 'heart-outline'} />
        { isFavorite ? 'Unfavorite' : 'Favorite'}
      </button>
    );
  }

  function renderView(store) {
    const state = store.getState();

    const toggleFavorite = (id) => {
      api.post(`/lots/${id}/toggle-favorite`).then(() => {
        store.dispatch(toggleFavoriteLot(id));
      });
    }

    ReactDOM.render(
      <App state={state} toggleFavorite={toggleFavorite} />,
      document.getElementById('root')
    );
  }

  store.subscribe(() => {
    renderView(store);
  });

  renderView(store);

  setInterval(() => {
    store.dispatch(setTime(new Date()));
  }, 1000);

  api.get('/lots').then((lots) => {
    store.dispatch(setLots(lots));

    lots.forEach((lot) => {
      stream.subscribe(`price-${lot.id}`, (data) => {
        store.dispatch(changeLotPrice(data.id, data.price));
      });
    });
  });

  function render(virtualDom, realDomRoot) {
    const evaluatedVirtualDom = evaluate(virtualDom);

    const virtualDomRoot = {
      type: realDomRoot.tagName.toLowerCase(),
      props: {
        id: realDomRoot.id,
        ...realDomRoot.attributes,
        children: [
          evaluatedVirtualDom
        ]
      }
    }

    sync(virtualDomRoot, realDomRoot);
  }

  function evaluate(virtualNode) {
    if (typeof virtualNode !== 'object') {
      return virtualNode;
    }

    if (typeof virtualNode.type === 'function') {
      return evaluate(
        (virtualNode.type)(virtualNode.props)
      );
    }

    const props = virtualNode.props || {};

    return {
      ...virtualNode,
      props: {
        ...props,
        children: Array.isArray(props.children)
          ? props.children.map(evaluate)
          : [evaluate(props.children)]
      }
    }
  }

  function sync(virtualNode, realNode) {
    // sync element
    if (virtualNode.props) {
      Object.entries(virtualNode.props).forEach(([name, value]) => {
        if (name === 'children' || name === 'key') {
          return;
        }

        if (realNode[name] !== value) {
          realNode[name] = value;
        }
      });
    }

    if (virtualNode.key) {
      realNode.dataset.key = virtualNode.key;
    }

    if (typeof virtualNode !== 'object' && virtualNode !== realNode.nodeValue) {
      realNode.nodeValue = virtualNode;
    }

    // sync child nodes

    const virtualChildren = virtualNode.props
      ? virtualNode.props.children || []
      : [];
    const readChildren = realNode.childNodes;

    for (let i = 0; i < virtualChildren.length || i < readChildren.length; i++) {
      const virtualChild = virtualChildren[i];
      const realChild = readChildren[i];

      // Remove
      if (virtualChild === undefined && realChild !== undefined) {
        realNode.remove(realChild);
      }

      // Update
      if (virtualChild !== undefined && realChild !== undefined && (virtualChild.type || '') === (realChild.tagName || '').toLowerCase()) {
        sync(virtualChild, realChild);
      }

      // Replace
      if (virtualChild !== undefined && realChild !== undefined && (virtualChild.type || '') !== (realChild.tagName || '').toLowerCase()) {
        const newRealChild = createRealModeByVirtual(virtualChild);
        sync(virtualChild, newRealChild);

        realNode.replaceChild(newRealChild, realChild);
      }

      // Add
      if (virtualChild !== undefined && realChild === undefined) {
        const newRealChild = createRealModeByVirtual(virtualChild);
        sync(virtualChild, newRealChild);

        realNode.appendChild(newRealChild);
      }
    }
  }

  function createRealModeByVirtual(virtual) {
    if (typeof virtual !== 'object') {
      return document.createTextNode('');
    }

    return document.createElement(virtual.type);
  }

</script>

</body>
</html>

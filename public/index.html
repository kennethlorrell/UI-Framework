<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="styles.css">
    <title>ðŸ•µ Investigating Reactivity</title>
</head>
<body>

<div id="root"></div>

<script>

  const api = {
    get(url) {
      switch (url) {
        case '/lots': {
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve([
                {
                  id: 1,
                  name: 'Apple',
                  description: 'Apple description',
                  price: 16
                },
                {
                  id: 2,
                  name: 'Orange',
                  description: 'Orange description',
                  price: 41
                }
              ]);
            }, 1000)
          });
        }
        default: {
          throw new Error('Unknown address');
        }
      }
    }
  }

  const stream = {
    subscribe(channel, listener) {
      const match = /price-(\d+)/.exec(channel);

      if (match) {
        setInterval(() => {
          listener({
            id: parseInt(match[1]),
            price: Math.round((Math.random() * 10 + 30))
          });
        }, 400);
      }
    }
  }

  const VDom = {
    createElement: (type, config, ...children) => {
      const props = config || {};
      const key = config
        ? config.key || null
        : null;

      if (children.length === 1) {
        props.children = children[0];
      } else {
        props.children = children;
      }

      return {
        type,
        key,
        props
      };
    }
  }

  let state = {
    time: new Date(),
    lots: null
  }

  function App({ state }) {
    return VDom.createElement('div', { className: 'app' },
      VDom.createElement(Header),
      VDom.createElement(Clock, { time: state.time }),
      VDom.createElement(Lots, { lots: state.lots }),
    );
  }

  function Loading() {
    return VDom.createElement('div', { className: 'loading' }, 'Loading...');
  }

  function Header() {
    return VDom.createElement('header', { className: 'header' },
      VDom.createElement(Logo)
    );
  }

  function Logo() {
    return VDom.createElement('img', { className: 'logo', src: 'logo.png' });
  }

  function Clock({ time }) {
    const isDay = time.getHours() >= 7 && time.getHours() <= 21;

    return VDom.createElement('div', { className: 'clock' },
      VDom.createElement('span', { className: 'value' }, time.toLocaleTimeString()),
      VDom.createElement('span', { className: isDay ? 'icon day' : 'icon night' })
    );
  }

  function Lots({ lots }) {
    if (lots === null) {
      return VDom.createElement(Loading);
    }

    return VDom.createElement('div', { className: 'lots' },
      lots.map((lot) => VDom.createElement(Lot, { lot, key: lot.id }))
    );
  }

  function Lot({ lot, key }) {
    return VDom.createElement('article', { className: 'lot', key },
      VDom.createElement('div', { className: 'price' }, lot.price),
      VDom.createElement('h1', null, lot.name),
      VDom.createElement('div', null, lot.description)
    );
  }

  function renderView(state) {
    render(
      VDom.createElement(App, { state }),
      document.getElementById('root')
    );
  }

  renderView(state);

  setInterval(() => {
    state = {
      ...state,
      time: new Date()
    };

    renderView(state);
  }, 1000);

  api.get('/lots').then((lots) => {
    state = {
      ...state,
      lots
    };

    renderView(state);

    const onPrice = (data) => {
      state = {
        ...state,
        lots: state.lots.map((lot) => {
          if (lot.id === data.id) {
            return {
              ...lot,
              price: data.price
            }
          }
          return lot;
        })
      }

      renderView(state);
    }

    lots.forEach((lot) => {
      stream.subscribe(`price-${lot.id}`, onPrice);
    });
  });

  function render(virtualDom, realDomRoot) {
    const evaluatedVirtualDom = evaluate(virtualDom);

    const virtualDomRoot = {
      type: realDomRoot.tagName.toLowerCase(),
      props: {
        id: realDomRoot.id,
        ...realDomRoot.attributes,
        children: [
          evaluatedVirtualDom
        ]
      }
    }

    sync(virtualDomRoot, realDomRoot);
  }

  function evaluate(virtualNode) {
    if (typeof virtualNode !== 'object') {
      return virtualNode;
    }

    if (typeof virtualNode.type === 'function') {
      return evaluate(
        (virtualNode.type)(virtualNode.props)
      );
    }

    const props = virtualNode.props || {};

    return {
      ...virtualNode,
      props: {
        ...props,
        children: Array.isArray(props.children)
          ? props.children.map(evaluate)
          : [evaluate(props.children)]
      }
    }
  }

  function sync(virtualNode, realNode) {
    // sync element
    if (virtualNode.props) {
      Object.entries(virtualNode.props).forEach(([name, value]) => {
        if (name === 'children' || name === 'key') {
          return;
        }

        if (realNode[name] !== value) {
          realNode[name] = value;
        }
      });
    }

    if (virtualNode.key) {
      realNode.dataset.key = virtualNode.key;
    }

    if (typeof virtualNode !== 'object' && virtualNode !== realNode.nodeValue) {
      realNode.nodeValue = virtualNode;
    }

    // sync child nodes

    const virtualChildren = virtualNode.props
      ? virtualNode.props.children || []
      : [];
    const readChildren = realNode.childNodes;

    for (let i = 0; i < virtualChildren.length || i < readChildren.length; i++) {
      const virtualChild = virtualChildren[i];
      const realChild = readChildren[i];

      // Remove
      if (virtualChild === undefined && realChild !== undefined) {
        realNode.remove(realChild);
      }

      // Update
      if (virtualChild !== undefined && realChild !== undefined && (virtualChild.type || '') === (realChild.tagName || '').toLowerCase()) {
        sync(virtualChild, realChild);
      }

      // Replace
      if (virtualChild !== undefined && realChild !== undefined && (virtualChild.type || '') !== (realChild.tagName || '').toLowerCase()) {
        const newRealChild = createRealModeByVirtual(virtualChild);
        sync(virtualChild, newRealChild);

        realNode.replaceChild(newRealChild, realChild);
      }

      // Add
      if (virtualChild !== undefined && realChild === undefined) {
        const newRealChild = createRealModeByVirtual(virtualChild);
        sync(virtualChild, newRealChild);

        realNode.appendChild(newRealChild);
      }
    }
  }

  function createRealModeByVirtual(virtual) {
    if (typeof virtual !== 'object') {
      return document.createTextNode('');
    }

    return document.createElement(virtual.type);
  }

</script>

</body>
</html>
